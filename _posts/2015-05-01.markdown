---
layout: post
title:  "Value Objects"
date:   2015-05-01
categories: DDD
---

<div class="introduction">
    <em>If we are talking about Value Objects, we are inside a specific context: Domainr-Driven Design. And What is Domain Driven Design? Is a way to produce quality in the software we develop. Some quality is reached by using tests avoiding delivering software with fatal number of bugs. Quality of software is reached via tests. Wuality of design could be reached with Domain-Driven Design. DDD gives you tools necessary to high-quality software. Value Objects are a vital building block of DDD.</em>

    <h2>What is a Value Object</h2>
    <p>Value Objects are Value Types that measures, quantify, or describe things. It's just a bundle ov values that comes and goes as needed. When designed correctly, a Value instance can be created, handed off, and forgotten about. A value object could be ...</p>
    <ul>
        <li>numbers</li>
        <li>text strings</li>
        <li>dates</li>
        <li>times</li>
        <li>person's full name</li>
        <li>currecy</li>
        <li>color</li>
        <li>phone number</li>
        <li>postal addresses</li>
        <li>email address</li>
        <li>json</li>
        <li>uri</li>
        <li>url</li>
        <li>...</li>
        <li>an event</li>
        <li>http message</li>
        <li>http status code</li>
    </ul>

    <h2>Ubiquitous Language</h2>
    <p>Is a shared team language. It's shared by domain experts and developers. In fact, it's shared by everyone on the project team. No matter your role on the team, since you are on the team you use the Ubiquitous Language of the project. Is not an adoption of business language. Is not industry standard. Is a language developed by the team, composed of both domain experts and software developers.</p>

    <h2>How do we determine if a domain concept should be modeled as a Value?</h2>
    <p>To answer, we need to pay attention to its characteristics. When you care only about the attributes of an element of the model, classify it as a Value Object. Treat the Value Object as immutable. Don't give it any identity and avoid the design complexities necessary to mantain Entities.</p>
    <p>If we are interested of a value and not about an identity, we need a value object. Is ONE sum of values that an entity can assume. A value object, could be equals to more entities. And more entities could be equals to one value object.</p>
</div>

<div class="characteristics">
    <h2>Characteristics</h2>
    <p>When you are trying to decide if a concept is a Value, you should determine whether it possesses most of these characteristics:</p>
    <ul>
        <li>measures, quantifies, or describes a thing in the domain</li>
        <li>immutable</li>
        <li>conceptual whole</li>
        <li>replaceable</li>
        <li>equality</li>
        <li>Side-Effect-Free</li>
    </li>

    <h2>Measures, Quantifies or Describes</h2>
    <p>A Value Object is not a thing of our domain. A person has an age. Age is not a thing. Age measures an amount of years. A person has a name. The name is not a thing. Name describes how the person is called. Name is a description? Name is a Value Object.</p>

    <h2>Immutable</h2>
    <p>This means that Value Object are stateless. We cannot modify a value object. Setters violate immutability.</p>
    <p>In some implementation, in other languages, setters are allowed BUT with private visiblity. In these cases basic attribute initialization is oerfirned first by invoking basic private setters.</p>
    <p>You can design a Value Object handled to one or more Entities. But is not a good idea because if Entity change, Value changes too, and this is a violation of the quality of immutability. State cannot change! Is Value Object you have disigned need state changement, consider the idea to use an Entity.</p>
    <code>
        <?php
        namespace Sensorario\PugMi\ValueObjects;
        final class EmailAddress {
            // we need a public constructor?
            private function __construct() {
                // ...
            }
            // named constructor
            public static function withDomain($domain) {
                return new self(compact('domain'));
            }
            // named constructor
            public static function withAddress($address) {
                return new self(compact('address'));
            }
        }
    </code>

    <h2>Conceptual Whole</h2>
    <p>Only toghether, the one, two or a number of individual attributes, form the complete intended measure or description.</p>
    <p>"50/EUR" contains two attributes: "50" and "EUR". Separately these attributes describes something else or nothing special. These attributes are a <strong>Conceptual Whole</strong> that describe a monetary measure. What we care about is not just an amount or just a currency. To properly describe a thing, it must be trated not as two separate attributes, but as a whole value.</p>
    <code>
        <?php
        namespace Sensorario\PugMi\ValueObjects;
        public final class MonetaryMeasure {
            public static function withAmountAndCurrency($amount, $currency) {
                return new self(compact(
                    'amount',
                    'currency'
                ));
            }
        }
    </code>
    <p>Each attribute (necessary) is defined! A Value Object is a sort of defined state. A Value Object is a container of attributes.</p>
    <code>
        <?php
        namespace Sensorario\PugMi\ValueObjects;
        $person = new Person();
        $person->name('Simone');
        $person->company('Onebip');
    </code>
    <p>The name of attributes must reflect this characteristic.</p>
    <code>
        MonetaryMeasure::withAmountAndCurrency(50, "EUR");
    </code>
    <!--<p>This is not perfect. We can use additiona type such as Currency. Or Amount.</p>
    <code>
        <?php
        namespace Sensorario\Pug\ValueObjects;
        public final class MonetaryMeasure {
            public static function withAmountAndCurrency(Amount $amount, Currency $currency) {
                return new self([
                    "amount"   => $amount->value(),
                    "currency" => (string) $currency,
                ]);
            }
        }
    </code>
    <p>This makes VO more descriptive. And a Factory and possibly a Builder, can take care about VO creation.</p>
    <p>We can user other value object, to define a value object. In this case, the parent reference to a Value Object is not just an attribute. Rather, it is a property of the containing parent in the model that holds a reference to it. Also, ... in this case, names of attributes can be determined only after establishing our Bounded Context and its Ubiquitous Language.</p>
    <p>Use of plain string can cause problems. Defining a ThingName type instead, we can centralize all concerns dealing with the name of a ThingOfWorth.</p> -->

    <h2>Replaceabiliy</h2>
    <p>When an entire value is replaced, and still represent the currently correct whole.</p>
    <p>3 is a number. 42 is a number. 42 could completely replace 3. Che conceptual whole is "the answer". We'll not alter 3 value. We change total value to 42.</p>
    <code>
        <?php
        $answer = 3;
        $answer = 42;
    </code>
    <p>We have replaced the entire value. This is the point of Value Objects. The point of replacement. Is not an oversemplification. It is exactly what replacement does even when Value Object type is more complex than an integer.</p>
    <code>
        <?php
        namespace Sensorario\Pug\ValueObjects;
        $amount = "3/EUR";
        $amount = "4/EUR";
        $amount = "3/USD";
        $amount = "42/EUR";
    </code>
    <code>
        <?php
        namespace Sensorario\Pug\ValueObjects;
        $fullName = FullName::fromSurnameName("Gentili", "Simone");
        $fullName = FullName::fromSurameNickAndName("Gentili", "Demo", "Simone");

        $fullName = FullName::box([
            'surname' => "Gentili",
            'name'    => "Simone",
        ]);

        $fullName = FullName::box([
            'surname'  => "Gentili",
            'nickname' => "Demo",
            'name'     => "Simone",
        ]);
    </code>
    <p>Use a method to change the state of che concept "full name" should violate the immutability. Instead of change the value, we replace the previous fill name with the noew one. An entity should use our new Value Object to set the full name of Person class.</p>
    <p>Replacement is not practical. But replacement also responds to another characteristics of Value Objects: Side-Effect-Free Behavior. Each time we make some operation with a value object, if the kind (the class) is the same, the instance is totally renewed.</p>

    <h2>Equality</h2>
    <p>If both types and their attributes are equal, the Value are considered equal. Further, if any two or more Value instances are equal, you could assign any one of the equal Value instances to an Entity's property  and the assignment would not change the value of the property.</p>
    <p>Ask yourself if the concept you are designing must be an Entity identified uniqeuely from all other object or if it sufficiently supported using value equality. If the consept itself doesnt require unique identity, model it as a Value Object.</p>

    <h2>Side-Effect-Free Behavior</h2>
    <p>"Since no modification occurs when executing a specific operation, that operation is said to be side-effect free." All methods of a Value Objects are side-effect free, because they must not violate the immutability characteristics. We might see Value Objects only as attribute container</p>
    <p>Pure functional programming languages allow nothing but side-effect-free behavior, requiring all closures to receive and produce only immutable value objects.</p>
    <code>
        <?php
        namespace Sensorario\Pug\ValueObjects;
        $fullName = new FullName("Gentili", "Simone");
        $fullName->withNickname("Demo"); // modifiche perse
        $fullName = $fullName->withNickname("Demo");
    </code>
    <p>The method withNickname() must respect the side-effect-free rule. Value Objects are immutable. Thus, the method will generate new container of attributes. Thw use of methods withSomething(), make all more expressive. The method will be implemented in this way:</p>
    <code>
        <?php
        namespace Sensorario\Pug\ValueObjects;
        class FullName {
            private function __construct(array $params = []) {
                // ...
            }
            public static function withNickname($nickname) {
                return new self([
                    'name' => $this->name(),
                    'surname' => $this->name(),
                    'nickname' => $nickname,
                ]);
            }
        }
    </code>
    <p>Method must not modify the state. Every function will generate new value.</p>
    <p>This method also capture important business logic.</p>
    <p>When we pass an entity as a function parameter, we must not modify that entity. Why? the side-effect free does not regard only Value Object: it also regard the other domain parts. If we need to change the state of the entity, function can take the entity as input and return something the entity could use to modify itself, on its own terms and responsibility.</p>
</div>

<div class="standard-types">
    <p>Standard Types are descriptive obejects that indicates the type of things. Synonimous od standard type are called <em>type code</em> or <em>lookup</em>. PhoneNumber is a value. But phone number hide an information about the type. We need to describe it as personal number or work number. These descriptions represent standard type.</p>
    <p>In case of currency, standard types could be EUR, USD, ... and so on. Using a standard type helps avoid bogus currencies. Use a Value Object helps development avoiding bogus in values.</p>
    <p>Depending on the level of standardisation: type could be defined in a txt file, exel, ... OR accepted as international standards.</p>
    <code>
        <?php
        namespace Sensorario\PugMi\ValueObjects;
        final class HTTPStatusCodes {
            const OK        = 200;
            const NOT_FOUND = 404;
        }
    </code>
</div>

<div class="testing-value-objects">
    <p>Test first! Tests provinding examples of how a client will use each object. In TDD with Value Objects we are not really interested in unit testing. There is mre interest in demostrating how various objects in the doimain model will be used by clients and what thos clients can expect when they use them. If we are writing a user's manual for the model, we would provide these tests as the most appropriate code sample for how clients should use this specific object.</p>
    <p>There are different motications for each type of test. Unit test and behavioral test have their place, as do the following modeling tests. Tests should have domain meaning. Is not necessary to test value objects. Value objects can improve test by test when others parts tests grow up. To test Value Object we should use acceptance test.</p>
    <p>Value Object should not be moked. Characteristics of value object, about immutability and equality, should suggest that Value Objects are really tested in acceptance tests.</p>
</div>

<div class="implementation">
    <p>If all setter has private scope, there is no opportunity for attributes to be exposed to mutation by consumers.</p>
    <p>Fluent interface!</p>
    <code>
        <?php
        $valueObject = ValueObject::box([
            'attribute' => 'value',
        ]);

        $request = Request::withCode(200);
        $request = $request->andHeader('Referer', 'http://sensorario.github.io');
    </code>
</div>

<div class="persisting-value-object">
    <p>There are a variety of ways to persit Value Object instances to a persistent store. We are interested in persisting Values along with the state of the aggregate instances that contain them. These examples are based on the assumpion that an Aggregate is beign added to or read from its Repository, and its contained Values are persisted and reconstituted behind the scenes along with the Entity that contains them.</p>
    <p>ORM such Doctrine2 is popular and widely used. Using an ORM to map every class to a table and every attribute to a column adds complexity, which may be unwarranted.</p>
    <p>Most times that a Value Object is persisted to a data store, it is stored in a denormalized fashion. Its attributes are stored in the same database table row as its Entity object. This makes the storage and retrieval of Values clean and optimized and prevents any persistence store leakage into the model. It's both a pleasure and a relief when Values can be persisted this way.</p>
    <p>There are times when Value Objects in the model will of necessary be stored as an Entity with respect to a relational persistence store. When persisted an instance of a specific value object type will occupy its own row in a relational database table that exists specifically for its own row in a relational database table that exists specifically for its type, and it will have its own database primary key column. This happens when, when supporting a collection of Value Object instance with ORM. In such cases the Value type persistent data is modeled as a database entity.</p>
    <p>Is this an indication that the domain model object should reflect the design of the data model and be an Entity rather.</p>
    <p>Persisting a single Value Object instance to a database is straightforward. </p>
</div>

<div class="resources">
    <h1>Suggested Books</h1>
    <ul>
        <li>PHP Objects, Patterns, and Practicei</li>
    </ul>

    <h2>Links</h2>
    <ul>
        <li><a href="">wikipedia</a></li>
        <li><a href="http://verraes.net/2014/06/named-constructors-in-php/">named constructor</a></li>
    </ul>
</div>
